######  异常是什么：
异常是对问题的描述，将问题进行对象的封装。
######  异常体系的特点：
异常体系中的所有类以及建立的对象都具备可抛性，也就是说可以被thorw和throws关键字所操作。
#####   throw和throws的用法：

 - [ ] throw定义在函数内，用于抛出异常对象。
 - [ ] throws定义在函数上，用于抛出异常类，可以抛出多个异常类，中间用逗号隔开
 - [ ] 当函数内容有throw抛出异常对象，并未进行捕获处理，必须在函数上声明，否则会编译失败。
 - [ ] 注意：RuntimeException除外，也就是说，如果函数内抛出RuntimeException异常，可以在函数上声明，当然不声明也没有错误。如果函数声明了异常，那么调用者要么处理，要么也抛出去。
####  异常有两种
 - [ ] 编译时被检测异常（编译时异常）：该异常在编译时，如果没有被处理（throws/try）编译失败；
 - [ ] 运行时异常（编译时不检测）：在编译时不需要处理，编译器不检查。该异常的发生，建议不处理，让程序停止，需要对代码进行修正；
 

```
//异常处理语句
try{
需要被检测的代码
}
catch(){
处理异常的代码；
}
finally{
一定会执行的代码：
}
```
####   处理异常的三种格式

 - [ ] try-catch()
 - [ ] try-catch()-finally
 - [ ] try-finally
####  finally使用的几点注意：
 1. finally中定义的通常是  关闭资源的代码，因为资源必须被释放。比如说断开数据库连接。
 2. finally只有一种情况不会被执行。当执行到  System.exit(0);    finally不会被执行。 （对System.exit(0)不了解     [请点击](https://blog.csdn.net/Fly_Fly_Zhang/article/details/86563914)）
 3. finally当中最好不要使用return,因为catch不会执行，也就是说finally是先于catch执行的。
 4. 不要在finally中抛出异常。
 5. 减轻finally的负担，不要再finally中做一些事情，finally仅仅用来释放资源是最合适的。
####   自定义异常：
 - [ ] 定义类继承Exception或者RuntimeException原因有二：一是为了让该自定义类具备可抛性，二是让该类具备操作异常的共性方法。
 - [ ] 当要定义自定义异常信息时，可以使用父类已经定义好的功能，异常信息传递给父类的构造函数 ：super（message）
 - [ ] 自定义异常按照java的oop思想将程序中出现的特有问题进行封装。
####  异常的好处：
 1. 将问题进行封装；
 2. 将正常流程代码和问题处理代码相分离，提高代码的可读性；
####   异常的处理原则：
1. 要么抛要么处理  throws/try
2. 调用到抛出异常的函数（功能）时，抛出几个处理几个。一个try对应多个catch
3. 多个catch时，父类的catch放在最下面，因为如果放在最上面，父类可以处理子类所有的异常，那么下面的子类异常就没有要写的必要了。
4. catch块内需要定义针对性的处理方式，不要简单的定义printstackTrace 输出语句。 但是也不要不写，当捕获到的异常本功能处理不了时，可以在catch中继续抛出。如果该异常处理不了，但并不属于该功能常见的异常，可以将异常转换后，在抛出和该功能相关的异常或者异常可以处理，当需要将异常产生和本功能有关的问题提供出去，让调用者知道并进行处理。也可以将捕获的异常处理后转换成新的异常。
5. throw单独存在，后面不要放任何语句，因为执行不到。会发生编译失败。
####   异常的处理原则：
 - [ ] 在子父类覆盖时：子类抛出的异常必须是父类异常的子类或者子集。   如果父类或者接口没有抛出异常时，子内覆盖出现异常，不能抛只能try1
####   几个比较
 - [ ] final修饰变量成为常量；修饰类为密封类不能被继承；修饰方法，该方法在子类中不能被重写。
 - [ ] finally用于异常处理，try块中的代码不管有没有异常，finally块的代码都会执行，一般用于资源的释放。
 - [ ] finalize用于对象的回收，在GC回收某个对象时，对象的finalize方法会被先执行一遍

   

    

